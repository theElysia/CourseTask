## c++中各种函数调用方法速度测试
#### author: Zevick

本次实验测试了
+ Static Function
+ CRTP Class
+ Virtual Class
+ Pure Template Function
+ Lambda Function
+ Std::function

得到的结果如下：
```
性能测试 (迭代次数: 10000000):
==========================================
Static function     : time =   155214 us, result = 3.263567
CRTP class          : time =   172885 us, result = 3.263567
Virtual class       : time =   178395 us, result = 3.263567
Pure Template func  : time =   174694 us, result = 3.263567
Lambda function     : time =   171510 us, result = 3.263567
Std function        : time =   674691 us, result = 3.263567
```

附上测试代码：

```c++
#include <cstdio>
#include <cmath>
#include <functional>
#include <chrono>

using TEST_FUNC_TYPE = std::function<double(double)>;

template <typename Derive>
class GaussFunc_Interface
{
public:
    double operator()(double x)
    {
        return static_cast<Derive *>(this)->operator()(x);
    }
};

class GaussFunc_Virtual_Interface
{
public:
    virtual double operator()(double x) const = 0;
    virtual ~GaussFunc_Virtual_Interface() = default;
};

// 函数指针,支持static/lambda
double gauss_integration(double (*func)(double), int order = 1);

// std::function 类型擦除
double gauss_integration(const TEST_FUNC_TYPE &func, int order = 1);

// CRTP
template <typename Derive>
double gauss_integration(GaussFunc_Interface<Derive> &func, int order = 1);

// virtual inherit
double gauss_integration(GaussFunc_Virtual_Interface &func, int order = 1);

// 纯粹模板
template <typename T>
double gauss_integration(T &func, int order = 1);

// ==================测试函数定义====================

double test_func1(double x)
{
    static double a = 2, b = 2, c = 1;
    return a * x * x + b * x + c;
}

class Func2Class : public GaussFunc_Interface<Func2Class>
{
private:
    double a_, b_, c_;

public:
    Func2Class(double a, double b, double c) : a_(a), b_(b), c_(c) {}
    double operator()(double x) { return a_ * x * x + b_ * x + c_; }
};

class Func3Class : public GaussFunc_Virtual_Interface
{
private:
    double a_, b_, c_;

public:
    Func3Class(double a, double b, double c) : a_(a), b_(b), c_(c) {}
    double operator()(double x) const override { return a_ * x * x + b_ * x + c_; }
};

class Func4Class
{
private:
    double a_, b_, c_;

public:
    Func4Class(double a, double b, double c) : a_(a), b_(b), c_(c) {}
    double operator()(double x) const { return a_ * x * x + b_ * x + c_; }
};

// ==================测试函数定义====================

// 性能测试函数
template <typename Func>
void benchmark(const char *name, Func &&func, int iterations = 10000000)
{
    auto start = std::chrono::high_resolution_clock::now();

    double result = 0.0;
    for (int i = 0; i < iterations; ++i)
    {
        result += gauss_integration(func, 10);
        // 防止编译器过度优化
        asm volatile("" : "+r"(result));
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    printf("%-20s: time = %8ld us, result = %.6f\n",
           name, duration.count(), result / iterations);
}

int main()
{
    double a = 2, b = 2, c = 1;
    Func2Class test_func2(a, b, c);                 // CRTP
    Func3Class test_func3(a, b, c);                 // Virtual
    Func4Class test_func4(a, b, c);                 // pure template
    auto test_func5 = [a, b, c](double x) -> double // lambda function
    {
        return a * x * x + b * x + c;
    };

    printf("性能测试 (迭代次数: 10000000):\n");
    printf("==========================================\n");

    // 测试静态函数
    benchmark("Static function", test_func1);

    // 测试CRTP类
    benchmark("CRTP class", test_func2);

    // 测试虚函数类
    benchmark("Virtual class", test_func3);

    // 测试纯模板函数
    benchmark("Pure Template func", test_func4);

    // 测试lambda函数
    benchmark("Lambda function", test_func5);

    // 测试std::function
    benchmark("Std function", TEST_FUNC_TYPE(test_func1));

    printf("\n正确性验证:\n");
    printf("==========================================\n");
    printf("Static function: %.6f\n", gauss_integration(test_func1, 10));
    printf("CRTP class:      %.6f\n", gauss_integration(test_func2, 10));
    printf("Virtual class:   %.6f\n", gauss_integration(test_func3, 10));
    printf("Template func:   %.6f\n", gauss_integration(test_func4, 10));
    printf("Lambda function: %.6f\n", gauss_integration(test_func5, 10));
    printf("Std function:    %.6f\n", gauss_integration(TEST_FUNC_TYPE(test_func1), 10));

    return 0;
}

#define GAUSS_BODY                                              \
    switch (order)                                              \
    {                                                           \
    case 1:                                                     \
        return 2.0 * func(0.0);                                 \
    case 2:                                                     \
        return 1.0 * func(-0.5773502691896257) +                \
               1.0 * func(0.5773502691896257);                  \
    case 3:                                                     \
        return 0.8888888888888888 * func(0.0) +                 \
               0.5555555555555556 * func(-0.7745966692414834) + \
               0.5555555555555556 * func(0.7745966692414834);   \
    case 4:                                                     \
        return 0.6521451548625461 * func(-0.3399810435848563) + \
               0.6521451548625461 * func(0.3399810435848563) +  \
               0.3478548451374538 * func(-0.8611363115940526) + \
               0.3478548451374538 * func(0.8611363115940526);   \
    case 10:                                                    \
    default:                                                    \
        return 0.2955242247147529 * func(-0.1488743389816312) + \
               0.2955242247147529 * func(0.1488743389816312) +  \
               0.2692667193099963 * func(-0.4333953941292472) + \
               0.2692667193099963 * func(0.2190863625159820) +  \
               0.4333953941292472 * func(-0.6794095682990244) + \
               0.2190863625159820 * func(0.6794095682990244) +  \
               0.1494513491505806 * func(-0.8650633666889845) + \
               0.1494513491505806 * func(0.8650633666889845) +  \
               0.0666713443086881 * func(-0.9739065285171717) + \
               0.0666713443086881 * func(0.9739065285171717);   \
    }

double gauss_integration(double (*func)(double), int order)
{
    GAUSS_BODY
}

double gauss_integration(const TEST_FUNC_TYPE &func, int order)
{
    GAUSS_BODY
}

template <typename Derive>
double gauss_integration(GaussFunc_Interface<Derive> &func, int order)
{
    GAUSS_BODY
}

double gauss_integration(GaussFunc_Virtual_Interface &func, int order)
{
    GAUSS_BODY
}

template <typename T>
double gauss_integration(T &func, int order)
{
    GAUSS_BODY
}
```
